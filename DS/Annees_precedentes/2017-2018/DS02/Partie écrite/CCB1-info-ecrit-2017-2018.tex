\input{../../../Header_Willie}
\parindent=10pt
\textheight 250mm

  \pagestyle{fancy}
%  \fancyfoot[C]{\thepage}
  \fancyhead[LO,LE]{\bfseries {\large PTSI -- Dorian}}
  \fancyhead[RO,RE]{\bfseries{\large Informatique}}
  \fancyhead[CO,CE]{DS 16 décembre 2017}

\begin{document}

 \begin{center}
  \begin{large}
  \fbox{DS Informatique -- Partie écrite. Durée : 1 heure}
  \end{large}
 \end{center}

\begin{boxedminipage}{\textwidth} 
Lorsqu'on écrit un code Python : faire attention à ce que les indentations soient visibles sur la copie ; commenter le code de façon à expliquer les grandes étapes de l'algorithme en ajoutant un commentaire en fin de ligne de code après le symbole $\sharp$.
\end{boxedminipage}
 

\section{Question de TP -- Comparaison entre deux méthodes d'exponentiation}
\label{sec:ComparaisonExponentiation}
%wack page 104 + cours Renaud C05

On propose deux programmes différents pour l'exponentiation d'un réel positif $k$ par un entier strictement positif $n$ (c'est-à-dire le calcul de $k^n$). On suppose que $k$ est affecté d'une valeur réelle positive.

\begin{listing}
\begin{minted}[linenos,frame=lines]{python}
p = 1
c = n
while c > 0:
  p = p * k
  c = c - 1
\end{minted}
\caption{Première méthode d'exponentiation.}
\label{prog:exponentiationnaive}
\end{listing}

\begin{listing}
\begin{minted}[linenos,frame=lines]{python}
p = 1
c = n
while c > 0:
  if c%2 == 1:
    p = p * k
  k = k**2  
  c = c//2
\end{minted}
\caption{Deuxième méthode d'exponentiation.}
\label{prog:exponentiationrapide}
\end{listing}

\begin{enumerate}

\item Pour le programme~\ref{prog:exponentiationnaive}, identifier et prouver le variant et l'invariant de boucle.

\item On prend $n=13$. Pour chacun des deux programmes~\ref{prog:exponentiationnaive} et \ref{prog:exponentiationrapide}, déterminer et noter les valeurs ou expressions successives de $p$, $c$ et $k$ ainsi que le nombre d'itérations de la boucle Tant que.  

\item Compter le nombre d'opérations élémentaires dans chacune des boucles. En déduire lequel des deux programmes réalise une « exponentiation rapide ». 

\item On peut montrer que la \textit{complexité temps} du programme d'exponentiation rapide est $O(\log(n))$. Quelle est la \textit{complexité temps} de l'autre programme ?

\end{enumerate}

\section{Question de cours -- Algorithme d'Euclide}

Soient $a \in \mathbb N$ et $b \in \mathbb N^*$. Donner le code en python d'une fonction qui réalise l'algorithme d'Euclide déterminant le plus grand diviseur commun de $a$ et $b$.

\section{Exercice -- Expression de durées}
%http://pcsi.kleber.free.fr/IPT/doc/TP03_petits_exercices.pdf
% E.Bougnol, J.J. Fleck, M. Heckmann et M. Kostyra, Kléber, PCSI

On suppose déjà connue du programme deux listes \texttt{L1} et \texttt{L2} auxquelles sont affectées des durées $d_1$ et $d_2$ en jours, heures, minutes et secondes sous la forme de quatre entiers \texttt{[jours,heures,minutes,secondes]}. Donner un code python permettant d'exprimer la durée totale $d=d_1+d_2$ en jours, heures, minutes et secondes de façon unique. Par exemple : pour \texttt{L1=[1,23,45,57]} et \texttt{L2=[1,4,17,28]}, le résultat doit être la liste \texttt{[3,4,3,25]}.

Piste suggérée : d'abord convertir les durées en secondes puis convertir la somme des durées en jours, heures, minutes et secondes.

\end{document}


