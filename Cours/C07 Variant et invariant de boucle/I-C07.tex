\input{../../headers/beamercoursHeadings}

\section{Variant de boucle} 

\ifdef{\public}{\begin{frame}
\frametitle{Table des matières}
\tableofcontents[currentsection]
\end{frame}}{}

\begin{frame}[fragile]
\frametitle{Problématique}

\begin{obj}
L'objectif de ce cours et de savoir:
\begin{itemize}
 \item justifier qu'une boucle produit l'effet attendu au moyen d'un invariant,
 \item démontrer qu'une boucle se termine effectivement.
\end{itemize}
\end{obj}

\begin{minipage}{0.4\linewidth}
Algorithme 1 : Calcul de k\up{n} \\
Entrées: entier n, réel k \\
Sorties: réel puissance \\
c=n \\
puissance=1 \\
tant que c>0 faire \\
\hspace*{1cm} puissance=puissance*k \\
\hspace*{1cm} c=c-1 \\
retourner puissance
\end{minipage}\hfill
\begin{minipage}{0.56\linewidth}
Cet algorithme permet de calculer la n\up{ème} puissance de k.

Pour terminer cet algorithme, la variable $c$ est calculée à chaque itération, puis testée.

Ainsi, lorsqu'elle atteint une certaine valeur, la boucle s'arrête.

~\

\textbf{Comment prouver que cette boucle s'arrête ?}
\end{minipage}
\end{frame}

\begin{frame}[fragile]
\frametitle{Variant de boucle}

\begin{defi}
Soit une condition booléenne permettant de sortir d'une boucle constituée d'une comparaison entre une variable et une constante de types entiers positifs. La variable est un \textbf{variant de boucle} si elle est :
\begin{itemize}
 \item entière,
 \item bornée,
 \item strictement croissante ou décroissante.
\end{itemize}

Ainsi, après un nombre fini d'itérations, on est sûr que la boucle se terminera.
\end{defi}

\begin{rem}
\begin{itemize}
 \item Un variant de boucle permet de s'assurer qu'une boucle se terminera,
 \item Un variant de boucle ne permet pas de s'assurer qu'un algorithme fournit la réponse attendue.
\end{itemize}
\end{rem}
\end{frame}

\begin{frame}[fragile]
\frametitle{Exemple de variant de boucle}
Objectif: Montrer que l'algorithme 1 s'arrête.

Dans la boucle, $c$ est définie par la suite $\left\{c_i \right\}$ telle que, dans la boucle :

\ifdef{\public}{$\left\{\begin{array}{l}
c_0=n \\
c_{i+1}=c_i-1 \rightarrow \forall i, c_{i+1}<c_i \\
\forall i, c_i> 0
\end{array}\right.$}{$\left\{\begin{array}{l}
\\
\\
\end{array}\right.$}

~\

La suite $\left\{c_i \right\}$ est entière, positive et strictement décroissante.

~\

\textbf{Cela permet de justifier que l'algorithme s'arrête et $c$ est un variant de boucle}.
\end{frame}

\section{Invariant de boucle} 

\ifdef{\public}{\begin{frame}
\frametitle{Table des matières}
\tableofcontents[currentsection]
\end{frame}}{}

\begin{frame}[fragile]
\frametitle{Invariant de boucle}

\begin{defi}
Dans le cas des \textit{structures itératives}, un \textbf{invariant de boucle} est une propriété ou une formule logique:
\begin{itemize}
 \item qui est vérifiée après la phase d'initialisation,
 \item qui reste vraie après l'exécution d'une itération,
 \item qui, conjointement à la condition d'arrêt, permet de montrer que le résultat attendu est bien le résultat calculé.
\end{itemize}
\end{defi}

\begin{enumerate}
 \item Définir les préconditions (état des variables avant d'entrer dans la boucle).
 \item Définir un invariant de boucle.
 \item Prouver que l'invariant de boucle est vrai.
 \item Montrer la terminaison du programme.
 \item Montrer qu'en sortie de boucle, la condition reste vraie.
\end{enumerate}
\end{frame}

\begin{frame}[fragile]
\frametitle{Exemple d'invariant de boucle}
Objectif: Montrer que l'algorithme donne le résultat attendu.

Dans la boucle, deux suites $\left\{p_i \right\}$ (puissance) et $\left\{c_i \right\}$ sont définies par récurrence :

\ifdef{\public}{$\left\{\begin{array}{l l}
p_0=1 & p_{i+1}=k*p_i\\
c_0=n & c_{i+1}=c_i-1
\end{array}\right.$}{$\left\{\begin{array}{l}
\\
\end{array}\right.$}

~\

On veut montrer qu'en sortie de la boucle $p=k^n$.

Hypothèse: $P_i:p_i=k^{n-c_i}$ est un invariant de boucle.

\begin{itemize}
 \item $P_0:p_0=k^{n-c_0}=k^{n-n}=1$, VRAI,
 \item Hypothèse: $P_i:p_i=k^{n-c_i}$,
 \item $P_{i+1}:p_{i+1}=k*p_i=k*k^{n-c_i}=k^{n-(c_i-1)}=k^{n-c_{i+1}}$, VRAI.
\end{itemize}

\textbf{$P_i$ est un invariant de boucle et le résultat est le bon: $p=k^n$.}
\end{frame}

\ifdef{\public}{
\def\first{abc}
\def\second{cba}
}{\def\first{abc}
\def\second{abc}}

\ifx\first\second
\begin{frame}[fragile]
\frametitle{Exemple d'algorithme du PGCD sous python}
Objectif: Coder sous python cet algorithme.

\begin{minipage}{0.48\linewidth}
Data : a,b $\in \mathbb{N}^*$\\
x $\leftarrow$ a \\
y $\leftarrow$ b \\
tant que $y\neq0$ faire \\
\hspace*{0.5cm} r $\leftarrow$ reste de la division euclidienne de x par y \\
\hspace*{0.5cm} x $\leftarrow$ y \\
\hspace*{0.5cm} y $\leftarrow$ r \\
fin \\
Afficher x
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}

\begin{GrayBox}[0.7\textwidth]
\vspace{4cm}
\end{GrayBox}

\end{minipage}

\end{frame}
\else
\begin{frame}[fragile]
\frametitle{Exemple d'algorithme du PGCD sous python}
Objectif: Coder sous python cet algorithme.

\begin{minipage}{0.48\linewidth}
Data : a,b $\in \mathbb{N}^*$\\
x $\leftarrow$ a \\
y $\leftarrow$ b \\
tant que $y\neq0$ faire \\
\hspace*{0.5cm} r $\leftarrow$ reste de la division euclidienne de x par y \\
\hspace*{0.5cm} x $\leftarrow$ y \\
\hspace*{0.5cm} y $\leftarrow$ r \\
fin \\
Afficher x
\end{minipage}\hfill
\begin{minipage}{0.48\linewidth}

\begin{GrayBox}[0.7\textwidth]
\begin{verbatimtab}[3]
x=a
y=b
while y!=0:
	r=x%y
	x=y
	y=r
print x
\end{verbatimtab}
\end{GrayBox}

\end{minipage}

\end{frame}
\fi

\begin{frame}[fragile]
\frametitle{Application au PGCD: Variant de boucle}

\textbf{Déterminer le variant de boucle et montrer que la boucle se termine.}

\begin{minipage}{0.4\linewidth}
Data : a,b $\in \mathbb{N}^*$\\
x $\leftarrow$ a \\
y $\leftarrow$ b \\
tant que $y\neq0$ faire \\
\hspace*{0.5cm} r $\leftarrow$ reste de la division euclidienne de x par y \\
\hspace*{0.5cm} x $\leftarrow$ y \\
\hspace*{0.5cm} y $\leftarrow$ r \\
fin \\
Afficher x
\end{minipage}\hfill
\begin{minipage}{0.56\linewidth}

Par définition:
\begin{itemize}
 \item Le reste de la division euclidienne de $x$ par $y$, $r$, est un entier positif strictement inférieur à $y$,
 \item A chaque itération, y prend la valeur de r.
\end{itemize}

$\rightarrow$ Donc, $y$ décroit à chaque itération.\\
$\rightarrow$ \textbf{$y$ est un variant de boucle}.

\end{minipage}

\vspace{2cm}

\end{frame}

\begin{frame}[fragile]
\frametitle{Application au PGCD: Invariant de boucle}

\textbf{Montrer que \ifdef{\public}{$x_n=r_n+y_n.q_n$}{\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_} est un invariant de boucle et que la boucle donne le résultat attendu.}

\begin{minipage}{0.4\linewidth}
Data : a,b $\in \mathbb{N}^*$\\
x $\leftarrow$ a \\
y $\leftarrow$ b \\
tant que $y\neq0$ faire \\
\hspace*{0.5cm} r $\leftarrow$ reste de la division euclidienne de x par y \\
\hspace*{0.5cm} x $\leftarrow$ y \\
\hspace*{0.5cm} y $\leftarrow$ r \\
fin \\
Afficher x
\end{minipage}\hfill
\begin{minipage}{0.56\linewidth}
\begin{itemize}
 \item Initialement $x_0=a$ et $y_0=b$,
 \item On postule que l'invariant est $x$, or: $x=q.y+r \Leftrightarrow r=x-q.y$,
 \item Il existe un $r_1$ tel que $r_1=x_1-q_1.y_1$,
 \item Hypothèse $r_n=x_n-q_n.y_n$,
 \item Il existe $r_{n+1}=x_{n+1}-q_{n+1}.y_{n+1}$, avec $x_{n+1}=y_n$ et $y_{n+1}=r_n$,
 \item On a déjà montré que la boucle s'arrête avec $y=0$,
 \item En sortant de la boucle on a bien $x=r$,
 \item \textbf{$x$ est donc l'invariant de boucle}.
\end{itemize}

\end{minipage}

\vspace{2cm}

\end{frame}

\end{document}
