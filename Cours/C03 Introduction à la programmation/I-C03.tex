\input{../../headers/beamercoursHeadings}

\section{Les variables} 

\ifdef{\public}{\begin{frame}
\frametitle{Table des matières}
\tableofcontents[currentsection]
\end{frame}}{}

{\frame{
\frametitle{La programmation}

\begin{defi}
 \begin{itemize}
  \item L'immense majorité des programmes qui s'exécutent sur nos ordinateurs, téléphones et autres outils électroniques sont écrits dans des langages de programmation dits impératifs : \textbf{les lignes du programme sont exécutées les unes après les autres},
  \item Chaque ligne du programme effectue soit une opération simple, soit exécute une fonction qui est elle-même une suite d'opérations simples,
  \item Ces opérations sont des \textbf{instructions} ou des \textbf{expressions} qui manipulent des \textbf{variables}.
 \end{itemize}
\end{defi}
}}

\begin{frame}[fragile]
\frametitle{Les variables}

Une variable permet de stocker des informations. Une variable est définie par :
\\ ~\ \\
\begin{minipage}{0.45\linewidth}
\begin{itemize}
 \item un identificateur,
 \item un type,
\end{itemize}
\end{minipage}\hfill
\begin{minipage}{0.45\linewidth}
\begin{itemize}
 \item une valeur,
 \item une référence.
\end{itemize}
\end{minipage}

\textbf{Identificateur (nom de la variable) (lettres, chiffres, underscore)}
\begin{rem}
En python, les noms de variables suivants sont interdits :
\begin{tabular}{c c c c c c c c c}
and & as & assert & break & class & continue & def & True & try \\
del & elif & else & except & False & finally & for & while & \\
from & global & if & import & in & is & lambda & with & \\
None & nonlocal & not & or & pass & raise & return & yield & 
\end{tabular}
\end{rem}

\vspace{-0.5cm}

\begin{minipage}{0.4\linewidth}
\begin{GrayBox}[0.9\textwidth]
\begin{verbatimtab}[3]
>>> Booleen = True
>>> Entier = 2
>>> Reel = 3.456
>>> chaine = "coucou"
\end{verbatimtab}
\end{GrayBox}
\end{minipage}\hfill
\begin{minipage}{0.4\linewidth}
\end{minipage}


\end{frame}


\begin{frame}[fragile]
\frametitle{Les variables}

\textbf{Typage}

Le typage correspond à la nature de la variable (\textit{booléen, nombre entier, nombre réel, etc...}).

Le typage peut être:
\begin{itemize}
 \item \textbf{statique} lorsqu'il est nécessaire de définir le type d'une variable lors de sa création. On parle
de typage,
 \item \textbf{dynamique} lorsque, par exemple, le type le mieux adapté est choisi automatiquement lors de l'assignation
d'une variable.
\end{itemize}

\begin{GrayBox}[0.75\textwidth]
\begin{verbatimtab}[3]
# type permet de determiner le type d'une variable
>>> type(nbBooleen)
	<class 'bool'>
\end{verbatimtab}
\end{GrayBox}

\vspace{-0.2cm}

\textbf{Référence}

La référence permet de créer un alias pointant directement vers l'adresse mémoire d'une variable.

\end{frame}

\begin{frame}[fragile]
\frametitle{Les variables}

\textbf{Opérations}

Une opération est une combinaison arithmétique, relationnelle, logique,... de deux ou plusieurs variables. Le résultat dépend du type de variable.

Les principales opérations sont les suivantes :
\begin{itemize}
 \item l'addition : \verb|+|,
 \item la soustraction : \verb|-|,
 \item la multiplication : \verb|*|,
 \item l'exposant : \verb|**|,
 \item la division : \verb|/|,
 \item la division entière : \verb|//|,
 \item le modulo : \verb|%|,
 \item la comparaison : \verb|==|.
\end{itemize}

\end{frame}


\begin{frame}[fragile]
\frametitle{Types de variables}

\begin{itemize}
 \item les entiers,
 \item les réels,
 \item les booléens,
 \item les chaînes de caractères.
\end{itemize}

\begin{GrayBox}[0.75\textwidth]
\begin{verbatimtab}[3]
>>> a = 64 # affectation d'un entier
>>> a = 64.64 # affectation d'un reel
>>> a = True # affectation d'un booleen
>>> a = "a" # affectation d'un caractere
>>> 0b1000000 # Conv. binaire>decimal
	64
>>> 0x40 # Conv. hexa. > decimal
	64
\end{verbatimtab}
\end{GrayBox}
\end{frame}

\begin{frame}[fragile]
\frametitle{Les chaînes de caractères}

\begin{rem}
\begin{itemize}
 \item En raison des différences d'encodages entre les différents systèmes d'exploitation, des problèmes peuvent se poser
lors de l'affichage des caractères spéciaux tels les accents, les cédilles ...
 \item Séquences d'échappements :
 \begin{itemize}
  \item \verb|\n| provoque un retour à la ligne (retour chariot),
  \item \verb|\t| provoque une tabulation,
  \item \verb|\a| provoque une bip système,
  \item \verb|\"| et \verb|\?| permettent d'écrire un guillemet sans ouvrir ou fermer une chaîne de caractère,
  \item \verb|\\| permet d'écrire un antislash.
 \end{itemize}
\end{itemize}
\end{rem}

\begin{GrayBox}[0.75\textwidth]
\begin{verbatimtab}[3]
>>> a = 75011 ; b = "Lycee Dorian"
>>> print(a,": \t",b)
	75011 Lycee Dorian
\end{verbatimtab}
\end{GrayBox}
\end{frame}

\begin{frame}[fragile]
\frametitle{Les listes et les tableaux}

\textbf{Liste}

Une liste est une collection de plusieurs éléments qui peuvent avoir un type différent.

\begin{GrayBox}[0.85\textwidth]
\begin{verbatimtab}[3]
>>> x=[1,"b",3,"coucou"] # On affecte une liste à la variable x
>>> x[0] # Accès (affichage) a une variable
>>> x[0:2] # Accès (affichage) de x[0] a x[1]
>>> x.append(5) # Ajouter un element en fin de liste
>>> del(x[2]) # Supprime la valeur 3 de la liste x	
\end{verbatimtab}
\end{GrayBox}
\end{frame}

\section{Expressions et instructions} 

\ifdef{\public}{\begin{frame}
\frametitle{Table des matières}
\tableofcontents[currentsection]
\end{frame}}{}

\begin{frame}[fragile]
\frametitle{Expression}

Une expression est l'évaluation d'une opération. Un résultat est retourné.

\begin{GrayBox}[0.75\textwidth]
\begin{verbatimtab}[3]
>>> 1+1
	2
>>> 'a'+'a'
	'aa'
>>> 1 == 1
	True
\end{verbatimtab}
\end{GrayBox}
\end{frame}

\begin{frame}[fragile]
\frametitle{Instructions}

Une instruction est une action utilisée dans un algorithme ou dans un programme. Une instruction peut inclure une expression.

\begin{GrayBox}[0.75\textwidth]
\begin{verbatimtab}[3]
>>> a = 1
	1
>>> a = 2*3 # on affecte à a le résultat de l'expression
	6
>>> print(a)
	6
>>> type(a)
	<class ' int '>
\end{verbatimtab}
\end{GrayBox}

Remarque: il est impossible d'affecter une valeur à une expression, il est donc impossible de mettre une expression à gauche du signe =.

\end{frame}

\begin{frame}[fragile]
\frametitle{L'affectation}

\textbf{Affectation simple}

À cette variable on fait correspondre un identificateur (nom de la variable), une valeur, un type (booléen, entier, flottant ...) et une adresse mémoire. Tant que la variable n'est pas réaffectée, l'adresse mémoire reste inchangée.

\begin{GrayBox}[0.75\textwidth]
\begin{verbatimtab}[3]
>>> a=2
>>> id(a) # Permet de connaitre l'adresse memoire
	15590464
\end{verbatimtab}
\end{GrayBox}

\textbf{Affectation multiple}

L'affectation multiple permet l'affectation simultanément plusieurs variables.

\vspace{-0.5cm}

\begin{GrayBox}[0.75\textwidth]
\begin{minipage}[t]{0.4\linewidth}
\begin{verbatimtab}[3]
>>> a,b=1,2
>>> a
	1
\end{verbatimtab}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\linewidth}
\begin{verbatimtab}[3]
>>> b
	2
\end{verbatimtab}
\end{minipage}
\end{GrayBox}



\end{frame}

\begin{frame}[fragile]
\frametitle{Affectation multiple}

Les variables comme les tableaux ne peuvent pas être copiées aussi simplement que les variables simples :
\begin{GrayBox}[0.75\textwidth]
\begin{verbatimtab}[3]
>>> a,b=1,2
>>> tab1=[a,b]
>>> tab2=tab1
>>> id(tab1);id(tab2)
	19282320
	19282320
\end{verbatimtab}
\end{GrayBox}

Lors de la création de \verb|tab2|, python n'a pas créé un nouvel espace mémoire. Il a juste créé la variable \verb|tab2| et lui a adressé le même espace mémoire que \verb|tab1|. En conséquence, si on change un champ de \verb|tab1|, le même champ de \verb|tab2| sera modifié.
\end{frame}

\begin{frame}[fragile]
\frametitle{Affectation multiple}
En général, ce comportement n'est pas souhaité :

\begin{GrayBox}[0.75\textwidth]
\begin{minipage}[t]{0.4\linewidth}
\begin{verbatimtab}[3]
>>> tab1;tab2
	[1, 2]
	[1, 2]
>>> tab1[0]=0
\end{verbatimtab}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\linewidth}
\begin{verbatimtab}[3]
>>> tab1;tab2
	[0, 2]
	[0, 2]
\end{verbatimtab}
\end{minipage}
\end{GrayBox}

Ainsi, une méthode spéciale permet de recréer une nouvelle variable avec son adresse mémoire.

\begin{GrayBox}[0.75\textwidth]
\begin{minipage}[t]{0.4\linewidth}
\begin{verbatimtab}[3]
>>> tab2=tab1.copy()
>>> id(tab1);id(tab2)
	19282320
	20335832
\end{verbatimtab}
\end{minipage}\hfill
\begin{minipage}[t]{0.4\linewidth}
\begin{verbatimtab}[3]
>>> tab1[0]=4;tab1;tab2
	[4, 2]
	[0, 2]
\end{verbatimtab}
\end{minipage}
\end{GrayBox}



\end{frame}

\begin{frame}[fragile]
\frametitle{Affectation externe}

Lors de l'exécution d'un programme, il est possible de demander à l'utilisateur de saisir une donnée. Pour cela il existe des instructions permettant de communiquer avec l'utilisateur.

Dans Python, en utilisant la fonction input, les données saisies par l'utilisateur sont converties en chaîne de caractère.
\begin{GrayBox}[0.75\textwidth]
\begin{verbatimtab}[3]
>>>a=input()
\end{verbatimtab}
\end{GrayBox}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sorties à l'écran}

Lors de l'exécution d'un programme il est souvent nécessaire que ce dernier renvoie des informations à l'utilisateur pour,
par exemple, donner le résultat d'une opération ou encore donner l'avancement dans le programme.	

\begin{GrayBox}[0.75\textwidth]
\begin{verbatimtab}[3]
>>> print("Coucou") # Afficher une chaine de caract.
	Coucou
>>> i = 2
# Afficher une phrase composee.
>>> print("La valeur de i est ", i ,".", sep=")
# sep=" permet de supprimer l'espace entre 2 et le point
	La valeur de i est 2.
\end{verbatimtab}
\end{GrayBox}
\end{frame}

%\section{La programmation objet} 
%
%\ifdef{\public}{\begin{frame}
%\frametitle{Table des matières}
%\tableofcontents[currentsection]
%\end{frame}}{}
%
%\begin{frame}[fragile]
%\frametitle{Notions de programmation orientée objets}
%
%\begin{itemize}
% \item Classes, objets et méthodes Une classe est une structure particulière de programmation. Par instanciation d'une classe, il est alors possible de créer des objets,
% \item Une classe définit les attributs et des méthodes qui pourront être appliquées à l'objet.
%\end{itemize}
%
%Nous allons créé une classe permettant de gérer des points dans $\mathbb{R}^3$.
%
%\vspace{-0.5cm}
%
%\begin{GrayBox}[0.75\textwidth]
%\begin{verbatimtab}[3]
%class Point3d(object ):
%	"""Creation d'un point de l'espace"""
%p = Point3d()
%\end{verbatimtab}
%\end{GrayBox}
%
%Un attribut est une donnée propre à l'objet. Le point p a comme attribut ses 3 coordonnées. On pourrait donc créer un point à partir de ses coordonnées.
%
%\vspace{-0.5cm}
%
%\begin{GrayBox}[0.75\textwidth]
%\begin{verbatimtab}[3]
%class Point3d(object ):
%	""" Point de l 'espace $\mathbb{R}^3$"""
%	def __init__(self,coordx,coordy,coordz):
%		"""Creer un point a partir de 3 coordonnees"""
%\end{verbatimtab}
%\end{GrayBox}
%\end{frame}
%		
%\begin{frame}[fragile]
%\frametitle{Notions de programmation orientée objets}		
%
%\begin{GrayBox}[0.75\textwidth]
%\begin{verbatimtab}[3]
%		self .x = coordx
%		self .y = coordy
%		self .z = coordz
%
%>>> p = Point3d(1,2,3)
%>>> p.z
%	3
%\end{verbatimtab}
%\end{GrayBox}
%
%\vspace{-0.5cm}
%
%\textbf{Méthode}
%
%Le point p a comme attribut ses 3 coordonnées. On pourrait donc créer un point à partir de ses coordonnées.
%
%\vspace{-0.2cm}
%
%\begin{GrayBox}[0.75\textwidth]
%\begin{verbatimtab}[3]
%import math
%
%class Point3d(object ):
%	""" Creation d'un point de l 'espace"""
%\end{verbatimtab}
%\end{GrayBox}
%\end{frame}
%		
%\begin{frame}[fragile]
%\frametitle{Notions de programmation orientée objets}		
%
%\begin{GrayBox}[0.75\textwidth]
%\begin{verbatimtab}[3]
%	def __init__(self,coordx,coordy,coordz):
%		"""Creer un point a partir de 3 coordonnees"""
%		self .x = coordx
%		self .y = coordy
%		self .z = coordz
%	def distance ( self ,pt ):
%	""" Calcule la distance entre 2 points"""
%	dist = math.sqrt(( self .x-pt.x)**2
%					+(self .y-pt.y)**2
%					+(self .z-pt.z)**2)
%	return dist
%
%>>> p1=Point3d(0,0,0)
%>>> p2=Point3d(1,1,1)
%>>> p1.distance(p2)
%	1.7320508075688772
%\end{verbatimtab}
%\end{GrayBox}
%\end{frame}

\begin{frame}[fragile]
\frametitle{Exemple de programme}

\textbf{L'algorithme d'Euclide}

\begin{savoir}
\begin{enumerate}
 \item Pour $a,b$ deux entiers, on dit que $b$ divise $a$ si $a$ s'écrit $k.b$ avec $k$ un entier (ex : 3 divise 75),
 \item Pour $a,b\in \mathbb{N}$, non tous deux nuls, on note $PGCD(a,b)$ le plus grand diviseur commun à $a$ et à $b$,
(ex : PGCD(75,40) = 5),
 \item Pour tout entier naturel $a$, $PGCD(a,0) = a$ (tout entier divise $0$).
\end{enumerate}
\end{savoir}

Soient $a,b$ deux entiers naturels, avec $b$ non nul. On note $q$ le quotient et $r$ le reste dans la division euclidienne de $a$ par $b$.

On a : $a=b.q+r$, et on sait que $a=k.a_1$ et $b=k.b_1$, ainsi: \\
$k.a_1=k.b_1.q+r$, avec $a_1,b_1,k,q,r$ entiers naturels, ainsi, il existe un $r_1$ tel que $k.a_1=k.b_1.q+k.r_1$, tel que
$PGCD(a,b) = PGCD(b,r)$

\end{frame}

\begin{frame}[fragile]
\frametitle{Exemple de programme}

\begin{minipage}{0.45\linewidth}
Calcul de $PGCD(5810,1125)$
\end{minipage}\hfill
\begin{minipage}{0.45\linewidth}
\begin{enumerate}
 \item \ifdef{\public}{$5810=1125\times 5 + 185$}{....................................................},
 \item \ifdef{\public}{$1125=185\times 6 + 15$}{....................................................},
 \item \ifdef{\public}{$185=15\times 12 + 5$}{....................................................},
 \item \ifdef{\public}{$15=5\times 3 + 0$}{....................................................}.
\end{enumerate}
\end{minipage}

\begin{GrayBox}[0.9\textwidth]
\begin{verbatimtab}[3]
def Euclide_PGCD(a,b): # nom de la fonction et ses variables
	r=a%b	 			# on calcule le reste dans
						# la division de a par b
	while r!=0: 	# tant que ce reste est non nul :
			a=b 		# b devient le nouveau a
			b=r 		# r devient le nouveau b
			r=a%b 	# on recalcule le reste
	return(b) 		# une fois la boucle terminée,
						# on retourne le dernier b
pgcd(5810,1125)  # resultat retourné par la fonction
\end{verbatimtab}
\end{GrayBox}

\vspace{-0.5cm}

\end{frame}

\end{document}
